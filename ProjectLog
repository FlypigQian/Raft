这里记录了我在做 raft consensus algorithm 的时候的所思所想，作为工程进度保存着。

我一开始看着面包的代码，结构都能看得懂，不懂的地方在于gRPC的具体实现以及C++11的函数对象特性。但是最糊涂的地方在于我找不到他的程序入口，
找不到他的程序执行的逻辑。

在和面包聊天之后，他告诉我很多东西都是开了线程的，我这才反应过来。现在我开始做一个总结，里面必须掺杂着我的理解，然后和面包的代码进行对比，
最后批判性地分析我的思路是否可行。这个思考可以是high-level的，把时间限制的考虑延后吧。

周五的codereview上不需要考虑client，但是我还是在思考的时候小小地考虑一下。

server 的结构组织形式是怎么样的？当我们的 server 开起来的时候，到底发生了什么？？？

server 要执行的任务：满足外部 client 的需求，满足自己 consensus algorithm 的实现。

对用户来说，满足 client 需求的接口是隐藏、封装掉了 consensus algorithm 的实现的，它才不管你现在是 follower、candidate、还是
leader，也就是说我可以独立开一个线程给用户，那个线程就是在处理 rpc 问题。因为 server 不可能主动发消息给用户，只是用户发送请求，
而 server 进行半被动地回复，因此那个线程所需要的功能就是监听用户请求，一旦监听到了，那么就调用一些函数来进行这些请求的访问与查找，
那么这些函数要操作 server 当中的 map 内容，因此这些操作是下克上的函数调用，应该使用bind之类的骚操作。
对于不同的 identity，这些对于用户的借口应该是多态的封装掉的函数。

对于 consensus algorithm 的实现，server 当中需要一个独立的 raft 逻辑来实现，这个 raft 逻辑要做什么？？？
raft 要按照算法规则维护自己的 identity，并且更新自己的 log，以及根据自己的状态去领导别人更新别人的 log，以及
对用户的请求进行响应，对整个服务器集群的 log 写入一个 entry。
整个算法逻辑是一个状态机，这个状态机的触发有两个途径：1. RPC、2. timer。
raft 逻辑需要发送各种rpc，并且监听各种rpc，而这些rpc我都不会！！！需要去学习。
“RPC接收端也有自己的线程的，并且它会自动调用你的函数，你把 server 开起来应该就没什么事情要做了。”

这个时候我们来想一想会出现什么样的情况？

诶对了！既然我上文说到状态机的触发只有两个途径，那么我就开两个线程，去等待状态机的触发。然后因为有两个东西同时在等待状态机的触发，
如果有两个事件同时触发了状态机，并且它们要让状态机做出的动作有冲突的话，那么就会出现时序问题，因此我需要一个 eventQueue 来存放
我需要处理的任务，然后单独开一个线程监听 eventQueue，在有任务的时候执行任务，没有任务的时候等待执行。

并且状态机的触发主要在于RPC，因此 raft 的主要算法逻辑都实现在 rpc server 那里。它一旦接收到 rpc，就在它的线程当中作出相应的
反应。或者还是塞入eventQueue呢？（到时候再看看大包哥的代码吧，我感觉放到eventQueue里面去比较合适。但其实因为我还不知道gRPC
具体是如何作用的，因此我现在的想法也没什么说服力）。 
这样的话总体的架构就为：rpc、timer、eventQueue。

因为我现在还不会gRPC，但是我又想写一点代码，所以我还是先写timer和eventQueue。